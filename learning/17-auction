//SPDX-License-Identifier: MIT
pragma solidity ^0.8;

contract Auction {

    address public owner;               //address of smart contract's owner
    address public beneficiary;         //owner of goods owner

    uint256 public auctionStartTime;    //the specified time for the start of the auction
    uint256 public auctionEndTime;      //the specified time for the end of the auction

    uint256 public highestBid;          //highest price
    address public highestBider;        //aaderss of highest price person

    bool ended;                         //cheking the status of auction completion

    mapping( address => uint256) pendingRefunds; 

    struct Bid {
        address bider;
        uint256 bidPrice;
    }

    Bid[] internal bidArray; //define a array of structs
                             // [{bider1,bidPrice1},{bider2,bidPrice2},...]

    constructor() {
        owner= msg.sender;
    }

    modifier onlyOwner {
        require (msg.sender== owner,"Only owner can call this function!");
        _;
    }

    modifier isValidTime {
        require (block.timestamp< auctionEndTime,"Auction has been ended!");
        _;
    }

    modifier isHighestBid {
        require (msg.value> highestBid, "Value is less than highest bid!");
        _;
    }

    function startAuction(address _beneficiary, uint256 _basePrice, uint256 _deadlineDur) public onlyOwner{
        
        beneficiary = _beneficiary;
        //at the bigging of the auction, the beneficiary is considered the winner by determining the basePrice.
        highestBid = _basePrice;
        highestBider = _beneficiary;
        
        auctionStartTime= block.timestamp;
        auctionEndTime= block.timestamp + _deadlineDur; //deadline duration is on seconds
    }

    function bid() public isValidTime payable {
    }

    function refunds() public returns(bool){
    }

    function payToBeneficiary() public onlyOwner returns(bool){
    }

    //If the auction's time has ended,it updates the flag
    function endAuction() public onlyOwner {
        require(block.timestamp> auctionEndTime,"Auction can't end at this time!");
        ended= true;
    }

    function getBid() public view returns(Bid[] memory){
    }

    function getWinner() public view returns(address,uint256){
        return(highestBider,highestBid);
    }

    function paySend(address to,uint256 amount) public returns(bool){
        require(address(this).balance >amount, "NOT enough Balance!");
        bool result= payable(to).send(amount);
        require(result == true, "Payment is failure via Send!");
        return result;
    }


}
